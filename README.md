# multimixer-128
Multimixer-128: Universal Keyed Hashing Based on Integer Multiplication

## Overview

$Multimixer_{128}$ is a universal keyed hashing algorithm, based on just integer arithmetic ( addition and multiplication ), proposed in paper https://ia.cr/2023/1357. 

A keyed hash function, takes a key and a variable length message as input, compressing it to a fixed length digest. The keyed hashing scheme proposed in $Multimixer_{128}$ paper, takes equal length key and message ( meaning long keys will be required, in case message is long ) s.t. they are multiple of block size ( = 32 -bytes ) and compresses them into a 64 -bytes digest. It's proved to be an ε-∆universal hash function with ε = $2^{−127}$. It can be used during the compression phase of a message authentication code computation scheme. It can also be used in the compression phase of the Farfalle construction - which are used for building deck functions.

As $Multimixer_{128}$ is just based on integer arithmetic, which is pretty fast on most processors, it shows quite promising results during benchmarks. See [below](#benchmarking).

You can also find more details on how to start using $Multimixer_{128}$ API, [below](#usage).

## Prerequisites

Rust stable toolchain; see https://rustup.rs for installation guide.

```bash
# When developing this library, I was using
$ rustc --version
rustc 1.73.0 (cc66ad468 2023-10-03)
```

## Testing

For ensuring functional correctness and conformance to the specification of $Multimixer_{128}$ i.e. https://ia.cr/2023/1357 ( and its reference implementation https://github.com/Parisaa/Multimixer ), I use known answer tests that I've generated by following instructions described in https://gist.github.com/itzmeanjan/a32eab0244af55eba2847c6472337535.

```bash
cargo test --lib
```

## Benchmarking

Issue following command for benchmarking public function $f_{128}$ and $Multimixer_{128}$, with variable ( non-zero multiple of 32 -bytes ) length input key and message, on target CPU.

> **Note**
When benchmarking on `x86`, `x86_64`, `loongarch64` targets, CPU cycles and cycles/ byte metrics are reported, using `rdtsc` instruction, though for other targets, default wallclock timer of criterion.rs is used for reporting time and throughput. I found https://github.com/pornin/crrl/blob/73b33c1efc73d637f3084d197353991a22c10366/benches/util.rs pretty useful for obtaining CPU cycles when benchmarking Rust functions. But I'm using criterion.rs as benchmark harness, hence I decided to go with https://crates.io/crates/criterion-cycles-per-byte plugin, much easier to integrate.

```bash
RUSTFLAGS="-C opt-level=3 -C target-cpu=native" cargo bench --features="internal"
```

### On 12th Gen Intel(R) Core(TM) i7-1260P

```bash
f_128/f-128 (cached)    time:   [8.7446 cycles 8.7943 cycles 8.8479 cycles]
                        thrpt:  [0.2765 cpb 0.2748 cpb 0.2733 cpb]
Found 10 outliers among 100 measurements (10.00%)
  1 (1.00%) low severe
  3 (3.00%) low mild
  6 (6.00%) high mild
f_128/f-128 (random)    time:   [26.3272 cycles 26.4420 cycles 26.5575 cycles]
                        thrpt:  [0.8299 cpb 0.8263 cpb 0.8227 cpb]
Found 6 outliers among 100 measurements (6.00%)
  3 (3.00%) low mild
  1 (1.00%) high mild
  2 (2.00%) high severe

multimixer_128/32 (cached)
                        time:   [17.1940 cycles 17.2176 cycles 17.2419 cycles]
                        thrpt:  [0.2694 cpb 0.2690 cpb 0.2687 cpb]
Found 5 outliers among 100 measurements (5.00%)
  4 (4.00%) high mild
  1 (1.00%) high severe
multimixer_128/32 (random)
                        time:   [90.9891 cycles 91.1255 cycles 91.2606 cycles]
                        thrpt:  [1.4259 cpb 1.4238 cpb 1.4217 cpb]
Found 16 outliers among 100 measurements (16.00%)
  6 (6.00%) low severe
  2 (2.00%) low mild
  3 (3.00%) high mild
  5 (5.00%) high severe

multimixer_128/64 (cached)
                        time:   [29.1678 cycles 29.1828 cycles 29.1986 cycles]
                        thrpt:  [0.2281 cpb 0.2280 cpb 0.2279 cpb]
Found 5 outliers among 100 measurements (5.00%)
  1 (1.00%) low mild
  4 (4.00%) high mild
multimixer_128/64 (random)
                        time:   [104.6465 cycles 105.2168 cycles 105.8072 cycles]
                        thrpt:  [0.8266 cpb 0.8220 cpb 0.8176 cpb]
Found 2 outliers among 100 measurements (2.00%)
  1 (1.00%) low severe
  1 (1.00%) low mild

multimixer_128/128 (cached)
                        time:   [52.1477 cycles 52.1700 cycles 52.1925 cycles]
                        thrpt:  [0.2039 cpb 0.2038 cpb 0.2037 cpb]
Found 5 outliers among 100 measurements (5.00%)
  1 (1.00%) low mild
  3 (3.00%) high mild
  1 (1.00%) high severe
multimixer_128/128 (random)
                        time:   [140.1373 cycles 141.3493 cycles 142.7056 cycles]
                        thrpt:  [0.5574 cpb 0.5521 cpb 0.5474 cpb]
Found 6 outliers among 100 measurements (6.00%)
  3 (3.00%) low severe
  3 (3.00%) low mild

multimixer_128/256 (cached)
                        time:   [98.4494 cycles 98.5948 cycles 98.7517 cycles]
                        thrpt:  [0.1929 cpb 0.1926 cpb 0.1923 cpb]
Found 2 outliers among 100 measurements (2.00%)
  1 (1.00%) high mild
  1 (1.00%) high severe
multimixer_128/256 (random)
                        time:   [190.3371 cycles 191.2902 cycles 192.3897 cycles]
                        thrpt:  [0.3758 cpb 0.3736 cpb 0.3718 cpb]
Found 9 outliers among 100 measurements (9.00%)
  5 (5.00%) low severe
  1 (1.00%) low mild
  2 (2.00%) high mild
  1 (1.00%) high severe

multimixer_128/512 (cached)
                        time:   [192.0255 cycles 192.4331 cycles 192.8309 cycles]
                        thrpt:  [0.1883 cpb 0.1879 cpb 0.1875 cpb]
Found 5 outliers among 100 measurements (5.00%)
  2 (2.00%) low mild
  2 (2.00%) high mild
  1 (1.00%) high severe
multimixer_128/512 (random)
                        time:   [298.1982 cycles 299.8530 cycles 301.5130 cycles]
                        thrpt:  [0.2944 cpb 0.2928 cpb 0.2912 cpb]

multimixer_128/1024 (cached)
                        time:   [389.2597 cycles 389.7680 cycles 390.2933 cycles]
                        thrpt:  [0.1906 cpb 0.1903 cpb 0.1901 cpb]
Found 4 outliers among 100 measurements (4.00%)
  3 (3.00%) high mild
  1 (1.00%) high severe
multimixer_128/1024 (random)
                        time:   [521.7002 cycles 526.6490 cycles 531.1559 cycles]
                        thrpt:  [0.2594 cpb 0.2572 cpb 0.2547 cpb]

multimixer_128/2048 (cached)
                        time:   [749.0771 cycles 749.6615 cycles 750.2349 cycles]
                        thrpt:  [0.1832 cpb 0.1830 cpb 0.1829 cpb]
Found 10 outliers among 100 measurements (10.00%)
  2 (2.00%) low mild
  6 (6.00%) high mild
  2 (2.00%) high severe
multimixer_128/2048 (random)
                        time:   [989.7291 cycles 1001.5923 cycles 1012.1123 cycles]
                        thrpt:  [0.2471 cpb 0.2445 cpb 0.2416 cpb]

multimixer_128/4096 (cached)
                        time:   [1467.8455 cycles 1468.2857 cycles 1468.7237 cycles]
                        thrpt:  [0.1793 cpb 0.1792 cpb 0.1792 cpb]
Found 6 outliers among 100 measurements (6.00%)
  3 (3.00%) high mild
  3 (3.00%) high severe
multimixer_128/4096 (random)
                        time:   [1837.5680 cycles 1858.4250 cycles 1875.8456 cycles]
                        thrpt:  [0.2290 cpb 0.2269 cpb 0.2243 cpb]
```

## Usage

Using $Multimixer_{128}$ hasher API is pretty straight-forward.

1) Add `multimixer-128` to Cargo.toml, as your project dependency.

```toml
[dependencies]
multimixer-128 = { git = "https://github.com/itzmeanjan/multimixer-128" }
```

2) Get non-zero, equal length key and message s.t. their byte length is a multiple of block size (= 32 -bytes), as input.

```rust
use multimixer_128;

fn main() {
    const BLOCKS: usize = 1;
    const MLEN: usize = multimixer_128::BLOCK_SIZE * BLOCKS;

    // Beware, this is just an example key !
    let key = [0x0fu8; MLEN];
    let msg = [0xf0u8; MLEN];
    let mut dig = [0u8; multimixer_128::DIGEST_SIZE];

    // ...
}
```

3) Compute 64 -bytes message digest.

```rust
fn main() {
    // ...

    multimixer_128::multimixer_128(&key, &msg, &mut dig);
    assert_eq!(dig, [1, 0, 0, 0, 254, 255, 255, 255, 1, 0, 0, 0, 254, 255, 255, 255, 1, 0, 0, 0, 254, 255, 255, 255, 1, 0, 0, 0, 254, 255, 255, 255, 9, 0, 0, 0, 250, 255, 255, 255, 9, 0, 0, 0, 250, 255, 255, 255, 9, 0, 0, 0, 250, 255, 255, 255, 9, 0, 0, 0, 250, 255, 255, 255]);
}
```

I'm maintaining an example program, demonstrating usage of $Multimixer_{128}$ API, living inside [examples](./examples/) directory.

```bash
cargo run --example multimixer_128

Key     = e02f28d290bd51df3b103396debe7f2ffc90b837588e37b13a7cc8cccce9fa11
Message = 1511ad54daae3df6706e33d9953f5dff4eabb2da85ad1added1aba2e0b571397
Digest  = d2324595d842cb028205c1f00328ba760d292a690452726d95728070ee7ff21e8e6af14b1e4c6d15404e709fd1fec952da3e3b7b3fe7d038fca793f3b4d7661a
```
